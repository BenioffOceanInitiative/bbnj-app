---
title: "data_prep"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Get HexIDs for High Seas

- [h3](https://crazycapivara.github.io/h3-r/articles/h3.html)

- [bbnj::p_abnj](https://benioffoceaninitiative.github.io/bbnj/reference/p_abnj.html)
- https://github.com/crazycapivara/h3-r/blob/master/inst/examples/nc-polyfill.R

- [h3:polyfill](https://crazycapivara.github.io/h3-r/reference/polyfill.html)\
  Get all hexagons with centers contained in a given polygon\
  `hex_ids <- polyfill(bbnj::p_abnj)`
  https://crazycapivara.github.io/h3-r/reference/polyfill.html 
  
- [h3::h3_set_to_multi_polygon](https://crazycapivara.github.io/h3-r/reference/h3_set_to_multi_polygon.html)\
  Create a (multi) polygon describing the outline(s) of a set of hexagons
  `hex_sf <- h3::h3_set_to_multi_polygon(hex_ids)`
  analyze existing raster layers with these to populate planning units and features for prioritizr

```{r}
# install.packages("crazycapivara/h3-r")
librarian::shelf(
  BenioffOceanInitiative/bbnj,
  deckgl, dplyr, geojsonsf, glue, here, jsonlite,
  crazycapivara/h3, leaflet, sf)

# get polygons for ABNJ (outside EEZ)
abnj <- bbnj::p_abnj

# get hexagon IDs for ABNJ polygons
hex_res <- 2
hex_geojson <- glue(here("data/abnj_hex_res{hex_res}.geojson"))
hexids_json <- glue("abnj_hexids_res{hex_res}.json")
hexids_www  <- here(glue("www/{hexids_json}"))
hexids_url  <- glue("https://shiny.ecoquants.com/bbnj-app/{hexids_json}")
hex_ids <- h3::polyfill(abnj, res = hex_res) 
hexids_js <- jsonlite::toJSON(list(list(
  abnj = unbox(1),
  hexIds = hex_ids)))
writeLines(hexids_js, hexids_www)

# create multipolygon describing outline of hexagons (for prioritizr)
hex_sf <- h3::h3_set_to_multi_polygon(hex_ids) 
hex_gj <- geojsonsf::sfc_geojson(hex_sf)

writeLines(hex_gj, hex_geojson)
```

## Map `hex_sf` with `leaflet`

```{r}
# works with leaflet , though maybe CRS is off?
leaflet(data = hex_sf, width = "100%") %>% 
  addProviderTiles("Stamen.Toner") %>% 
  addPolygons(
    # weight = 2,
    color = "white",
    fillColor = "white",
    fillOpacity = 0.7)
```

## Map `hex_ids` with `deckgl`


```{r}
properties <- list(
  stroked = TRUE,
  filled = TRUE,
  extruded = FALSE,
  getHexagons = ~hexIds,
  # getFillColor = JS("d => [255, (1 - d.abnj / 500) * 255, 0]"),
  getFillColor = JS("d => [255, 255, 0]"),
  getLineColor = c(255, 255, 255),
  lineWidthMinPixels = 2,
  getTooltip = ~abnj
)
hexids_url = "https://shiny.ecoquants.com/bbnj-app/abnj_hexids_res0.json"
deckgl(zoom = 10.5, pitch = 20) %>%
  add_h3_cluster_layer(data = hexids_url, properties = properties) %>%
  add_basemap()
```



### sf example

```{r}
# sample_data <- jsonlite::fromJSON(data_url, simplifyDataFrame = FALSE)
sf_json <- "https://raw.githubusercontent.com/uber-common/deck.gl-data/master/website/sf.h3clusters.json"

properties <- list(
  stroked = TRUE,
  filled = TRUE,
  extruded = FALSE,
  getHexagons = ~hexIds,
  getFillColor = JS("d => [255, (1 - d.mean / 500) * 255, 0]"),
  getLineColor = c(255, 255, 255),
  lineWidthMinPixels = 2,
  getTooltip = ~mean
)

deckgl(zoom = 10.5, pitch = 20) %>%
  add_h3_cluster_layer(data = sf_json, properties = properties) %>%
  add_basemap()
```


## OLD: experimental
  
```{r, eval=FALSE}

# write geojson with hexagon geoboundaries
# test: 
hexagon <- hex_ids[1]

# get_h3_id_attrs <- function(h3_id) {
#   list(
#     coordinates = c(h3::h3_to_geo(h3_id)),
#     geo_boundary = h3::h3_to_geo_boundary(h3_id))
# }

# feed hexids into new json for map display



h3_cells <- system.file("sample-data/h3-cells.csv", package = "deckgl") %>% read.csv()
get_h3_id_attrs(h3_id)

h3_id = hex_ids[1]
hexagon = hex_ids[1]

get_h3_id_attrs <- function(hexagon) {
  jsonlite::toJSON(
    list(
      hex_id          = hexagon,
      coordinates     = h3::h3_to_geo(hexagon),
      # geo_boundary    = sf::st_polygon(h3::h3_to_geo_boundary(hexagon)),
      sf_geo_boundary = h3::h3_to_geo_boundary_sf(hexagon),
      parent          = h3::h3_to_parent(hexagon, res = 0),
      children        = h3::h3_to_children(hexagon, res = 2))) # or sub other res
}

test <- get_h3_id_attrs(hex_ids[1])


json <- map(hex_ids, get_h3_id_attrs) %>% 
  jsonlite::toJSON()






get_h3_id_attrs(hex_ids[1])


hex_attrs <- map(hex_ids, get_h3_id_attrs)

ply_sfc_geojson <- geojsonsf::sfc_geojson(hex_sfc)
hex_sf_geojson  <- geojsonsf::sf_geojson(h3::h3_to_geo_boundary_sf(hexagon))


props <- list(
  extruded = TRUE,
  cellSize = 200,
  elevationScale = 4,
  getPosition = ~lng + lat,
  tooltip = "Count: {{count}}"
)

ply_sf_df <- data.frame(hex_sf) 
props <- list(
  stroked = TRUE,
  filled = TRUE,
  extruded = FALSE,
  getPolygons = ~geometry,
  getLineColor = c(255, 255, 255),
  lineWidthMinPixels = 2)

data <- data("sf_bike_parking")
# test, can't get hex's / multipolygon to show...
deckgl(zoom = 11, pitch = 45) %>%
  add_basemap() %>% 
  add_polygon_layer(data = ply_sf_df, properties = props)
  # add_grid_layer(data = data, properties = props)
  
  add_polygon_layer(
    data       = ply_sfc_geojson, 
    properties = list(
      stroked = TRUE,
      filled = TRUE,
      extruded = FALSE,
      getPolygons = ~coordinates,
      getFillColor = c(255, 255, 255),
      getLineColor = c(255, 255, 255),
      lineWidthMinPixels = 2)) %>% 
  add_basemap()
  


# render hexagons
# h3_index <- hex_sf %>% unlist(recursive = F) %>% unlist(recursive = F)
```

```{r}
# plot to test
hex_sfc %>% sf::st_geometry() %>% plot(col = "blue")


deckgl(zoom = 0) %>% 
  add_basemap() %>% 
  add_h3_cluster_layer(
    data = hex_sfc,
    properties = list(
      stroked = TRUE,
      filled = TRUE,
      extruded = FALSE,
      getHexagons = ~hexIds,
      getFillColor = JS("d => [255, (1 - d.mean / 500) * 255, 0]"),
      getLineColor = c(255, 255, 255),
      lineWidthMinPixels = 2)
    )
  







h3_cluster_props <- list(
  id = "h3-cluster-layer",
  stroked = TRUE,
  filled = TRUE,
  extruded = FALSE,
  getHexagons = ~hexIds,
  getFillColor = JS("d => [255, (1 - d.mean / 500) * 255, 0]"),
  getLineColor = c(255, 255, 255),
  lineWidthMinPixels = 2)

deckgl(zoom = 10.5, pitch = 20) %>%
  add_h3_cluster_layer(data = hex_ids, properties = h3_cluster_props) %>%
  add_basemap()


deckgl::deckgl(zoom = 0, pitch = 20) %>%
  deckgl::add_basemap() %>% 
  deckgl::add_h3_cluster_layer(
    data       = hex_json, 
    properties = props)


  


# deckgl
hex_cluster_props <- list(
  stroked = TRUE,
  filled = TRUE,
  extruded = FALSE,
  getHexagons = ~hexIds,
  getFillColor = JS("d => [255, (1 - d.mean / 500) * 255, 0]"),
  getLineColor = c(255, 255, 255),
  lineWidthMinPixels = 2,
  getTooltip = ~mean
)



  # pickable = FALSE,
  # stroked = TRUE,
  # filled = TRUE,
  # extruded = FALSE,
  # getPolygon = ~geometry,
  # # getHexagons  = ~hexIds, # ~hexIds
  # getFillColor = "blue",
  # # getFillColor = JS("d => [255, (1 - d.mean / 500) * 255, 0]"),
  # # getLineColor = c(255, 255, 255),
  # getTooltip   = ~mean,
  # lineWidthMinPixels = 2)

hex_geojson <- geojsonsf::sfc_geojson(hex_sf)


# d_poly <- tibble(contour = hex_sf)
  
# hex_props <- list(
#   id = "poly_layer",
#   data = hex_geojson,
#   pickable = TRUE,
#   stroked = TRUE,
#   filled = TRUE,
#   extruded = FALSE,
#   wireframe = FALSE,
#   lineWidthMinPixels = 1,
#   getPolygon = JS("d => d.contour"),
#   # getElevation = JS("d => d.population / d.area / 10"),
#   # getFillColor = JS("d => [d / d.area / 60, 140, 0]"),
#   getLineColor = c(80, 80, 80),
#   getLineWidth = 250)
# 
# deckgl(zoom = 0) %>% 
#   add_polygon_layer(data = hex_geojson, properties = hex_props) %>%
#   add_basemap()


deckgl::deckgl(zoom = 0, pitch = 20) %>%
  deckgl::add_basemap() %>% 
  deckgl::add_polygon_layer(
    data       = hex_sf, 
    properties = properties)
```





